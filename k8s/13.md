# Lab 13

## Task 2 

### Research and Documentation

```
yaroslav@xiaomao ~/S/D/d/k8s (lab13)> kubectl get po,sts,svc,pvc
NAME               READY   STATUS    RESTARTS   AGE
pod/app-python-0   1/1     Running   0          7m28s
pod/app-python-1   1/1     Running   0          7m28s

NAME                          READY   AGE
statefulset.apps/app-python   2/2     7m28s

NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE
service/app-python   NodePort    10.108.76.12   <none>        80:30456/TCP   2m12s
service/kubernetes   ClusterIP   10.96.0.1      <none>        443/TCP        30d

NAME                                      STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/data-app-python-0   Bound    pvc-f6fca879-f28b-4245-bd5d-c556e6b82292   1Gi        RWO            standard       89m
persistentvolumeclaim/data-app-python-1   Bound    pvc-9dee018d-6f7f-43bb-8b05-6b4ee4dc0b0b   1Gi        RWO            standard       89m
```

```
yaroslav@xiaomao ~/S/D/d/k8s (lab13)> kubectl exec app-python-0 -- cat visits.txt
26
yaroslav@xiaomao ~/S/D/d/k8s (lab13)> kubectl exec app-python-1 -- cat visits.txt
5
```

Amount of requests to first pod is bigger that amount of requests to the second service. This happend because of lack of load balancer, standard minikube service forwards most of requests to the first pod.


### Ordering Guarantee and Parallel Operations

Order of requests does not important for the application, because it's stateless. That's why we can run as many instances as we want.
